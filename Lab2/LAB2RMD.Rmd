---
title: "LAB2RMD"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r , message=FALSE}
# Duomenys 
# https://www.kaggle.com/datasets/brajeshmohapatra/bike-count-prediction-data-set?select=train.csv

library(tidyverse)
library(reshape2)
library(AER)
library(MASS)
library(goft)
library(lubridate)
```


```{r }
tr <- read.csv("train.csv")
te <- read.csv("test.csv")
te$count <- te$casual + te$registered
mega <- rbind(tr, te)
mega$hour <- hour(mega$datetime)
mega$day <- day(mega$datetime)
mega$yday <- yday(mega$datetime)
mega$wday <- wday(mega$datetime)
mega <- dplyr::select(mega, -c(datetime, casual, registered))
```


```{r}
head(mega)
```

```{r}
summary(mega)
```

```{r}
d <- mega[0:floor(0.90 * nrow(mega)),]
ggplot(d, aes(x=count)) + geom_histogram(bins = 100)
```

```{r}
ggplot(melt(d, "count"), aes(x = value, y = count, colour = variable)) + 
  geom_point() + 
  facet_wrap(~variable, scales = "free", nrow = 4)
```


```{r}
### Poisson
m1 <- glm(count ~ ., family="poisson", data=d)
summary(m1)

cat("Deviacija padalinta is laisves laipsniu: ",m1$deviance / m1$df.residual)
cat("Turi buti tarp 0.7 ir 1.3, tad nebegalime naudoti puasono modelio")
```

```{r }
### Negative Binomial
m2 <- glm.nb(count ~ ., data = d)
summary(m2)

cat("Deviacija padalinta is laisves laipsniu: ",m2$deviance / m2$df.residual)
```

## Cia reikia prielaidu
```{r }
# p1
# p2
# p3
# p4
```


```{r }
# # # NEVEIKIA NES LIBRARY SUGADINTAS # # #
### Zero deflated
#require(foreign)
#require(ggplot2)
#require(VGAM)
#require(boot)
#ztrunc <- vglm(count ~ ., family = posnegbinomial(), data = d)
#summary(ztrunc)
```


```{r }
### Stepwise
m2step <- stepAIC(m2, direction = "both")
summary(m2step)
cat("Deviacija padalinta is laisves laipsniu: ",m2step$deviance / m2step$df.residual)
```


```{r }
# Koeficientai
est <- cbind(Estimate = coef(m2step), confint(m2step))
exp(est)

```

```{r }
dopred <- function(tt, model) { 
  # Index
  index <- 1:nrow(tt)
  # Ground truth
  real <- tt$count
  # Predicted
  tt <- dplyr::select(tt, -count)
  predicted <- predict(model, newdata = tt, type = "response")
  # df
  tempdf <- data.frame(real, predicted, index)
  
  print(mean(abs((tempdf$real-tempdf$predicted)/tempdf$real)) * 100)
  p <- ggplot(tempdf, aes(x=index)) + 
      geom_line(aes(y = real), color = "#0F9D58") + 
      geom_line(aes(y = predicted), color="#4285F4", linetype="twodash") 
  return(p)
}
```



```{r }
v <- mega[floor(0.90 * nrow(mega)):nrow(mega),]

# Split to 4 datasets
num_groups = 4
totest <- v %>% 
  group_by((row_number()-1) %/% (n()/num_groups)) %>%
  nest %>% pull(data)

# Prediction for each dataset
plots <- list()
for (i in 1:num_groups) {
  plots[[i]] = dopred( data.frame(totest[i]), m2step)
}
plots

```






